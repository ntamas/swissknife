#!/usr/bin/env python
# vim:set ts=4 sw=4 sts=4 et:
"""\
Usage: %prog [options] [infile]

Plots columns from a data file using Matplotlib.
"""

from swissknife.error import AppError
from swissknife.utils import lenient_float, open_anything, parse_date, \
        parse_index_specification, TableWithHeaderIterator

from itertools import cycle, islice, izip, izip_longest
from numpy import arange, array, isnan, meshgrid, zeros, NaN
from numpy.ma import masked_where

import optparse
import re
import sys


DEFAULT_COLORS = 'bgrcmyk'

def create_option_parser():
    """Creates an `OptionParser` that parses the command line
    options."""

    def indexspec_callback(option, opt_str, value, parser):
        setattr(parser.values, option.dest,
                parse_index_specification(value))

    parser = optparse.OptionParser(usage=
            sys.modules[__name__].__doc__.strip())
    parser.add_option("-d", "--delimiter", metavar="DELIM",
            dest="delimiter", default="\t",
            help="use DELIM instad of TAB for field delimiter "
                 "in the input file")
    parser.add_option("-D", "--dates", metavar="AXES",
            dest="dates", choices=("none", "x"), default="none",
            help="assume that the given AXES contain dates. If AXES=none, "
                 "both the X and the Y coordinates will be treated as "
                 "numbers. If AXES=x, the X axis will be treated as a "
                 "date. Use --date-format to specify the format of the date. "
                 "Support for dates on the Y axis may be added later.")
    parser.add_option("--date-format", metavar="FORMAT",
            dest="date_format", default="%Y-%m-%d",
            help="use the given FORMAT to parse dates. FORMAT is a "
            "format string that must be accepted by datetime.strptime. "
            "Default: %default")
    parser.add_option("-f", "--fields", metavar="LIST",
            dest="fields", default=[], action="callback",
            type="str", callback=indexspec_callback,
            help="plot only these columns. For line plots (see -t), the "
                 "first index must always be the X coordinate, the rest "
                 "are Y coordinates of the points and possibly the sizes "
                 "of the error bars (if --errorbars is not none). For "
                 "3D plots, you need exactly three columns with the "
                 "X, Y and Z coordinates.")
    parser.add_option("-e", "--errorbars", metavar="AXES",
            dest="errorbars", choices=("none", "y"), default="none",
            help="use errorbars on the given AXES. If AXES=none, "
                 "no error bars will be used. If AXES=y, every second column "
                 "after the 2nd one (i.e. the 3rd, 5th, 7th etc) is assumed to "
                 "be an error bar for the value in the previous column. "
                 "Default: %default")
    parser.add_option("-o", "--output", metavar="FILE", dest="output",
            default=None, help="save the output to the given FILE")
    parser.add_option("-t", "--type", metavar="TYPE", dest="type",
            choices=("bar", "line", "scatter3d", "surface", "wireframe"),
            default="line",
            help="the type of plot to draw (bar, line, scatter3d, surface "
            "or wireframe)")
    parser.add_option("--strip", action="store_true", dest="strip", default=False,
            help="strip leading and trailing whitespace from each line")
    parser.add_option("--title", metavar="TITLE", dest="title",
            default=None, help="set the title of the plot to TITLE. "
            "The default title is the input filename.")
    parser.add_option("--twin", dest="twin", default=False,
            action="store_true", help="use two Y axes")
    parser.add_option("--xlabel", metavar="LABEL", dest="xlabel",
            default="", help="set the label of the X axis to LABEL")
    parser.add_option("--ylabel", metavar="LABEL", dest="ylabel",
            default="", help="set the title of the Y axis to LABEL")
    parser.add_option("--zlabel", metavar="LABEL", dest="zlabel",
            default="", help="set the title of the Z axis to LABEL (3D plots only)")

    return parser

def plot_file_on_figure(infile, figure, options):
    """Plots the dataset in the given file on the given figure."""
    iterator = TableWithHeaderIterator(
            open_anything(infile),
            delimiter=options.delimiter,
            fields=options.fields,
            strip=options.strip
    )
    iterator.first_column_is_date = ("x" in options.dates)
    func = globals()["plot_%s_from_table_iterator" % options.type]
    func(iterator, figure, options)

    # Add the title
    if options.title is None:
        if infile != "-":
            figure.suptitle(infile)
    else:
        figure.suptitle(options.title)


def add_axis_titles(axes, options):
    """Adds the titles on the given axes using the options given in
    `options."""
    # Add the axis titles
    if options.xlabel:
        axes.set_xlabel(options.xlabel)
    if options.ylabel:
        axes.set_ylabel(options.ylabel)
    if options.zlabel and hasattr(axes, "set_zlabel"):
        axes.set_zlabel(options.zlabel)


def parse_headers(headers):
    """Iterates over the headers of the input file and tries to
    extract style specifications out of them.

    A header contains a style specification if it ends with a substring in
    double square brackets (i.e. ``[[...]]``). This function will return
    two lists. The first contains the header strings *without* the style
    specifications (if there were any), the second contains the style
    specifications themselves or ``None`` if a header did not have a style
    specification at all."""
    if headers is None:
        return None, []

    new_headers, specs = [], []
    rex = re.compile(r"(.*)\[\[([^\]]+)]]$")
    for header in headers:
        match = rex.match(header)
        if match:
            new_headers.append(match.group(1).strip())
            specs.append(match.group(2))
        else:
            new_headers.append(header)
            specs.append(None)
    return new_headers, specs


def plot_bar_from_table_iterator(table_iterator, figure, options):
    """Plots the dataset whose rows will be yielded by the given
    `table_iterator` (an instance of `TableWithHeaderIterator`)
    using bar plots. The plot will be drawn on `figure`."""
    yss = []
    for values in table_iterator:
        # Less than one value? If so, skip this line.
        if len(values) < 1:
            continue

        # Not enough columns? Add the missing ones.
        if len(values) < len(yss):
            values.extend([None] * (len(yss)-len(values)))

        # For the time being, we put everything in yss and
        # will separate them later into Y coordinates and
        # error bars if options.errorbars is not none
        if not yss:
            # First row, must extend yss with columns
            yss = [[y] for y in values]
        else:
            for ys, y in izip(yss, values):
                ys.append(y)

    headers, style_overrides = parse_headers(table_iterator.headers)

    # Calculate the legend labels
    legend_handles, legend_labels = [], []
    if yss and headers is not None:
        legend_labels = headers[:]

    # Mask NaNs in yss
    yss = [[y if y is not None else NaN for y in ys] for ys in yss]
    yss = array(yss)
    yss = masked_where(isnan(yss), yss)

    # Handle error bars
    if options.errorbars == "y":
        # Separate the error bars from the values
        ncol = len(yss)
        errorbars = yss[1::2]
        yss = yss[::2]
        legend_labels = legend_labels[:min(len(legend_labels), ncol):2]
    else:
        # No error bars
        errorbars = None

    # Set up the colors to be used
    colors = DEFAULT_COLORS
    styles = list(colors)

    # Override the line styles where the header says so
    styles = [override if override is not None else style
            for style, override in izip_longest(styles, style_overrides[1:])]

    # Set up the list of axes we will use
    all_axes = [figure.gca()]
    if options.twin:
        all_axes.append(figure.gca().twinx())

    # Plot the bars
    xs = arange(0, len(yss[0]))
    bottoms = zeros(len(yss[0]))
    i = 0
    for axes, style, ys in izip(cycle(all_axes), cycle(styles), yss):
        params = dict(left=xs, height=ys, bottom=bottoms, color=style)
        if errorbars is not None:
            params["yerr"] = errorbars[i]
            i += 1

        handle = axes.bar(**params)
        legend_handles.append(handle[0])

        bottoms += ys

    # Add the axis titles
    add_axis_titles(all_axes[0], options)

    # Add the legend
    if legend_labels:
        legend_obj = all_axes[0].legend(legend_handles, legend_labels)
        legend_obj.legendPatch.set_alpha(0.75)

def plot_line_from_table_iterator(table_iterator, figure, options):
    """Plots the dataset whose rows will be yielded by the given
    `table_iterator` (an instance of `TableWithHeaderIterator`).
    The plot will be drawn on `figure`."""
    xs, yss = [], []
    for values in table_iterator:
        # Less than two values? If so, skip this line.
        if len(values) < 2:
            continue

        # Not enough columns? Add the missing ones.
        if len(values) < len(yss)+1:
            values.extend([None] * (len(yss)+1-len(values)))

        # The first value is the X coordinate. We put the
        # rest in yss and will separate them later into Y
        # coordinates and error bars if options.errorbars
        # is not none
        xs.append(values[0])
        if not yss:
            # First row, must extend yss with columns
            yss = [[y] for y in islice(values, 1, None)]
        else:
            for ys, y in izip(yss, islice(values, 1, None)):
                ys.append(y)

    headers, style_overrides = parse_headers(table_iterator.headers)

    # Calculate the legend labels
    legend_handles, legend_labels = [], []
    if yss and headers is not None:
        legend_labels = headers[1:]

    # If the x axis contains dates, map them to dates since 0001-01-01 UTC
    # since Matplotlib requires this
    if options.dates == "x" or options.dates == "xy":
        xs = [parse_date(x, format=options.date_format, default=NaN, ordinal=True)
                for x in xs]

    # Mask NaNs in xs
    xs = [x if x is not None else NaN for x in xs]
    xs = array(xs)
    xs = masked_where(isnan(xs), xs)

    # Mask NaNs in yss
    yss = [[y if y is not None else NaN for y in ys] for ys in yss]
    yss = array(yss)
    yss = masked_where(isnan(yss), yss)

    # Handle error bars
    if options.errorbars == "y":
        # Separate the error bars from the values
        ncol = len(yss)
        errorbars = yss[1::2]
        yss = yss[::2]
        legend_labels = legend_labels[:min(len(legend_labels), ncol):2]
    else:
        # No error bars
        errorbars = None

    # Set up the line styles to be used
    colors = DEFAULT_COLORS
    styles = '- -- -. :'.split()
    line_styles = [color+style for style in styles for color in colors]
    bar_styles = [color+'o' for style in styles for color in colors]

    # Override the line styles where the header says so
    line_styles = [override if override is not None else style
            for style, override in izip_longest(line_styles, style_overrides[1:])]
    bar_styles = [override if override is not None else style
            for style, override in izip_longest(bar_styles, style_overrides[1:])]

    # Set up the list of axes we will use
    all_axes = [figure.gca()]
    if options.twin:
        all_axes.append(figure.gca().twinx())

    # Plot the lines
    for axes, style, ys in izip(cycle(all_axes), cycle(line_styles), yss):
        if options.dates != "none":
            handle = axes.plot_date(xs, ys, style)
        else:
            handle = axes.plot(xs, ys, style)
        legend_handles.append(handle[0])

    # Plot the error bars if needed
    if errorbars is not None:
        for axes, style, ys, yerrs in izip(cycle(all_axes), \
                cycle(bar_styles), yss, errorbars):
            axes.errorbar(xs, ys, yerr=yerrs, fmt=style)

    # Add the axis titles
    add_axis_titles(all_axes[0], options)

    # Add the legend
    if legend_labels:
        legend_obj = all_axes[0].legend(legend_handles, legend_labels)
        legend_obj.legendPatch.set_alpha(0.75)

def plot_scatter3d_from_table_iterator(table_iterator, figure, options):
    """Plots a 3D scatterplot whose points come from the given `table_iterator`.
    The plot will be drawn on `figure`."""

    xs, ys, zs = [], [], []
    for values in table_iterator:
        # Less than three values? If so, skip this line.
        if len(values) < 3:
            continue
        # Any of the values missing? If so, skip this line
        if any(value is None for value in values):
            continue
        # Store the values
        xs.append(values[0])
        ys.append(values[1])
        zs.append(values[2])

    # Import 3D axes
    from mpl_toolkits.mplot3d import Axes3D

    # Create the axes
    axes = Axes3D(figure)

    # Plot the scatterplot
    axes.scatter(xs, ys, zs)

    # Add the axis titles
    add_axis_titles(axes, options)

    return figure

def plot_surface_from_table_iterator(table_iterator, figure, options, wireframe=False):
    """Plots a 3D surface whose points come from the given `table_iterator`.
    The plot will be drawn on `figure`."""

    xs, ys, zdict = set(), set(), {}
    for values in table_iterator:
        # Less than three values? If so, skip this line.
        if len(values) < 3:
            continue
        # Any of the values missing? If so, skip this line
        if any(value is None for value in values):
            continue
        # Store the values
        xs.add(values[0])
        ys.add(values[1])
        zdict[values[0], values[1]] = values[2]

    # Create the mesh grid and fill the Z values
    xs, ys = sorted(xs), sorted(ys)
    zs = zeros((len(xs), len(ys)))
    for i, x in enumerate(xs):
        for j, y in enumerate(ys):
            zs[i, j] = zdict.get((x, y), NaN)
    ys, xs = meshgrid(sorted(ys), sorted(xs))
    zs = masked_where(isnan(zs), zs)
    # Use the minimum value instead of NaNs -- this is because Matplotlib
    # won't apply the colormap if there are NaNs in the data
    zs = zs.filled(zs.min())

    # Import 3D axes
    from mpl_toolkits.mplot3d import Axes3D
    from matplotlib import cm

    # Create the axes
    axes = Axes3D(figure)

    # Plot the surface
    if wireframe:
        axes.plot_wireframe(xs, ys, zs)
    else:
        axes.plot_surface(xs, ys, zs, rstride=1, cstride=1, cmap=cm.jet)

    # Add the axis titles
    if options.xlabel:
        axes.set_xlabel(options.xlabel)
    if options.ylabel:
        axes.set_ylabel(options.ylabel)
    if options.zlabel:
        axes.set_zlabel(options.zlabel)

    return figure

def plot_wireframe_from_table_iterator(table_iterator, figure, options):
    """Plots a 3D  whose points come from the given `table_iterator`.
    The plot will be drawn on `figure`."""
    return plot_surface_from_table_iterator(table_iterator, figure, options,
            wireframe=True)

def main():
    """Main entry point of the script."""
    import matplotlib

    parser = create_option_parser()
    options, args = parser.parse_args()
    
    # Do we need headless mode for matplotlib?
    if options.output:
        matplotlib.use("agg")

    if options.fields:
        options.fields = [field-1 for field in options.fields]

    if not args:
        args.extend("-")

    from matplotlib import pyplot as plt
    figure = plt.figure()

    for infile in args:
        plot_file_on_figure(infile, figure, options)

    if options.output:
        plt.savefig(options.output)
    else:
        plt.show()

if __name__ == "__main__":
    try:
        sys.exit(main())
    except Exception as ex:
        print >>sys.stderr, ex
        import traceback
        traceback.print_exc(ex)
        sys.exit(1)
