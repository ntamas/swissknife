#!/usr/bin/env python
# vim:set ts=4 sw=4 sts=4 et:
"""\
Usage: %prog [options] [infile]

Plots columns from a data file using Matplotlib.
"""

from swissknife.error import AppError
from swissknife.utils import lenient_float, open_anything, parse_index_specification, \
        TableWithHeaderIterator

from itertools import cycle, islice, izip
from numpy import array, isnan, meshgrid, zeros, NaN
from numpy.ma import masked_where

import optparse
import sys

def create_option_parser():
    """Creates an `OptionParser` that parses the command line
    options."""

    def indexspec_callback(option, opt_str, value, parser):
        setattr(parser.values, option.dest,
                parse_index_specification(value))

    parser = optparse.OptionParser(usage=
            sys.modules[__name__].__doc__.strip())
    parser.add_option("-d", "--delimiter", metavar="DELIM",
            dest="delimiter", default="\t",
            help="use DELIM instad of TAB for field delimiter "
                 "in the input file")
    parser.add_option("-f", "--fields", metavar="LIST",
            dest="fields", default=[], action="callback",
            type="str", callback=indexspec_callback,
            help="plot only these columns. For line plots (see -t), the "
                 "first index must always be the X coordinate, the rest "
                 "are Y coordinates of the points and possibly the sizes "
                 "of the error bars (if --errorbars is not none). For "
                 "3D plots, you need exactly three columns with the "
                 "X, Y and Z coordinates.")
    parser.add_option("-e", "--errorbars", metavar="AXES",
            dest="errorbars", choices=("none", "y"), default="none",
            help="use errorbars on the given AXES. If AXES=none, "
                 "no error bars will be used. If AXES=y, every second column "
                 "after the 2nd one (i.e. the 3rd, 5th, 7th etc) is assumed to "
                 "be an error bar for the value in the previous column.")
    parser.add_option("-o", "--output", metavar="FILE", dest="output",
            default=None, help="save the output to the given FILE")
    parser.add_option("-t", "--type", metavar="TYPE", dest="type",
            choices=("line", "scatter3d", "surface", "wireframe"), default="line",
            help="the type of plot to draw (line, scatter3d, surface "
                 "or wireframe)")
    parser.add_option("--title", metavar="TITLE", dest="title",
            default=None, help="set the title of the plot to TITLE. "
            "The default title is the input filename.")
    parser.add_option("--twin", dest="twin", default=False,
            action="store_true", help="use two Y axes")
    parser.add_option("--xlabel", metavar="LABEL", dest="xlabel",
            default="", help="set the label of the X axis to LABEL")
    parser.add_option("--ylabel", metavar="LABEL", dest="ylabel",
            default="", help="set the title of the Y axis to LABEL")
    parser.add_option("--zlabel", metavar="LABEL", dest="zlabel",
            default="", help="set the title of the Z axis to LABEL (3D plots only)")

    return parser

def plot_file_on_figure(infile, figure, options):
    """Plots the dataset in the given file on the given figure."""
    iterator = TableWithHeaderIterator(
            open_anything(infile),
            delimiter=options.delimiter,
            fields=options.fields
    )
    func = globals()["plot_%s_from_table_iterator" % options.type]
    func(iterator, figure, options)

    # Add the title
    if options.title is None:
        figure.suptitle(infile)
    else:
        figure.suptitle(options.title)

def plot_line_from_table_iterator(table_iterator, figure, options):
    """Plots the dataset whose rows will be yielded by the given
    `table_iterator` (an instance of `TableWithHeaderIterator`).
    The plot will be drawn on `figure`."""
    xs, yss = [], []
    for values in table_iterator:
        # Less than two values? If so, skip this line.
        if len(values) < 2:
            continue

        # Not enough columns? Add the missing ones.
        if len(values) < len(yss)+1:
            values.extend([None] * (len(yss)+1-len(values)))

        # The first value is the X coordinate. We put the
        # rest in yss and will separate them later into Y
        # coordinates and error bars if options.errorbars
        # is not none
        xs.append(values[0])
        if not yss:
            # First row, must extend yss with columns
            yss = [[y] for y in islice(values, 1, None)]
        else:
            for ys, y in izip(yss, islice(values, 1, None)):
                ys.append(y)

    headers = table_iterator.headers

    # Calculate the legend labels
    legend_handles, legend_labels = [], []
    if yss and headers is not None:
        legend_labels = headers[1:]

    # Mask NaNs in xs
    xs = [x if x is not None else NaN for x in xs]
    xs = array(xs)
    xs = masked_where(isnan(xs), xs)

    # Mask NaNs in yss
    yss = [[y if y is not None else NaN for y in ys] for ys in yss]
    yss = array(yss)
    yss = masked_where(isnan(yss), yss)

    # Handle error bars
    if options.errorbars == "y":
        # Separate the error bars from the values
        ncol = len(yss)
        errorbars = yss[1::2]
        yss = yss[::2]
        legend_labels = legend_labels[:min(len(legend_labels), ncol):2]
    else:
        # No error bars
        errorbars = None

    # Set up the line styles to be used
    colors = 'bgrcmyk'
    styles = '- -- -. :'.split()
    line_styles = [color+style for style in styles for color in colors]
    bar_styles = [color+'o' for style in styles for color in colors]

    # Set up the list of axes we will use
    all_axes = [figure.gca()]
    if options.twin:
        all_axes.append(figure.gca().twinx())

    # Plot the lines
    for axes, style, ys in izip(cycle(all_axes), cycle(line_styles), yss):
        handle = axes.plot(xs, ys, style)
        legend_handles.append(handle)

    # Plot the error bars if needed
    if errorbars is not None:
        for axes, style, ys, yerrs in izip(cycle(all_axes), \
                cycle(bar_styles), yss, errorbars):
            axes.errorbar(xs, ys, yerr=yerrs, fmt=style)

    # Add the axis titles
    if options.xlabel:
        all_axes[0].set_xlabel(options.xlabel)
    if options.ylabel:
        all_axes[0].set_ylabel(options.ylabel)

    # Add the legend
    if legend_labels:
        legend_obj = all_axes[0].legend(legend_handles, legend_labels)
        legend_obj.legendPatch.set_alpha(0.75)

def plot_scatter3d_from_table_iterator(table_iterator, figure, options):
    """Plots a 3D scatterplot whose points come from the given `table_iterator`.
    The plot will be drawn on `figure`."""

    xs, ys, zs = [], [], []
    for values in table_iterator:
        # Less than three values? If so, skip this line.
        if len(values) < 3:
            continue
        # Any of the values missing? If so, skip this line
        if any(value is None for value in values):
            continue
        # Store the values
        xs.append(values[0])
        ys.append(values[1])
        zs.append(values[2])

    # Import 3D axes
    from mpl_toolkits.mplot3d import Axes3D

    # Create the axes
    axes = Axes3D(figure)

    # Plot the scatterplot
    axes.scatter(xs, ys, zs)

    # Add the axis titles
    if options.xlabel:
        axes.set_xlabel(options.xlabel)
    if options.ylabel:
        axes.set_ylabel(options.ylabel)
    if options.zlabel:
        axes.set_zlabel(options.zlabel)

    return figure

def plot_surface_from_table_iterator(table_iterator, figure, options, wireframe=False):
    """Plots a 3D surface whose points come from the given `table_iterator`.
    The plot will be drawn on `figure`."""

    xs, ys, zdict = set(), set(), {}
    for values in table_iterator:
        # Less than three values? If so, skip this line.
        if len(values) < 3:
            continue
        # Any of the values missing? If so, skip this line
        if any(value is None for value in values):
            continue
        # Store the values
        xs.add(values[0])
        ys.add(values[1])
        zdict[values[0], values[1]] = values[2]

    # Create the mesh grid and fill the Z values
    xs, ys = sorted(xs), sorted(ys)
    zs = zeros((len(xs), len(ys)))
    for i, x in enumerate(xs):
        for j, y in enumerate(ys):
            zs[i, j] = zdict.get((x, y), NaN)
    ys, xs = meshgrid(sorted(ys), sorted(xs))
    zs = masked_where(isnan(zs), zs)
    # Use the minimum value instead of NaNs -- this is because Matplotlib
    # won't apply the colormap if there are NaNs in the data
    zs = zs.filled(zs.min())

    # Import 3D axes
    from mpl_toolkits.mplot3d import Axes3D
    from matplotlib import cm

    # Create the axes
    axes = Axes3D(figure)

    # Plot the surface
    if wireframe:
        axes.plot_wireframe(xs, ys, zs)
    else:
        axes.plot_surface(xs, ys, zs, rstride=1, cstride=1, cmap=cm.jet)

    # Add the axis titles
    if options.xlabel:
        axes.set_xlabel(options.xlabel)
    if options.ylabel:
        axes.set_ylabel(options.ylabel)
    if options.zlabel:
        axes.set_zlabel(options.zlabel)

    return figure

def plot_wireframe_from_table_iterator(table_iterator, figure, options):
    """Plots a 3D  whose points come from the given `table_iterator`.
    The plot will be drawn on `figure`."""
    return plot_surface_from_table_iterator(table_iterator, figure, options,
            wireframe=True)

def main():
    """Main entry point of the script."""
    import matplotlib

    parser = create_option_parser()
    options, args = parser.parse_args()
    
    # Do we need headless mode for matplotlib?
    if options.output:
        matplotlib.use("agg")

    if options.fields:
        options.fields = [field-1 for field in options.fields]

    if not args:
        args.extend("-")

    from matplotlib import pyplot as plt
    figure = plt.figure()

    for infile in args:
        plot_file_on_figure(infile, figure, options)

    if options.output:
        plt.savefig(options.output)
    else:
        plt.show()

if __name__ == "__main__":
    try:
        sys.exit(main())
    except Exception as ex:
        print >>sys.stderr, ex
        import traceback
        traceback.print_exc(ex)
        sys.exit(1)
