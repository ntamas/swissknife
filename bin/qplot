#!/usr/bin/env python
"""\
Usage: %prog [options] [infile]

Plots columns from a data file using Matplotlib.
"""

from swissknife.error import AppError
from swissknife.utils import lenient_float, open_anything, parse_index_specification

from itertools import cycle, islice, izip
from matplotlib import pyplot as plt
from numpy import array, isnan, NaN
from numpy.ma import masked_where

import optparse
import sys

def create_option_parser():
    """Creates an `OptionParser` that parses the command line
    options."""

    def indexspec_callback(option, opt_str, value, parser):
        setattr(parser.values, option.dest,
                parse_index_specification(value))

    parser = optparse.OptionParser(usage=
            sys.modules[__name__].__doc__.strip())
    parser.add_option("-d", "--delimiter", metavar="DELIM",
            dest="delimiter", default="\t",
            help="use DELIM instad of TAB for field delimiter "
                 "in the input file")
    parser.add_option("-f", "--fields", metavar="LIST",
            dest="fields", default=[], action="callback",
            type="str", callback=indexspec_callback,
            help="plot only these columns. The first index must always "
                 "be the X coordinate, the rest are Y coordinates of "
                 "the points and possibly the sizes of the error bars "
                 "(if --errorbars is not none).")
    parser.add_option("-e", "--errorbars", metavar="AXES",
            dest="errorbars", choices=("none", "y"), default="none",
            help="use errorbars on the given AXES. If AXES=none, "
                 "no error bars will be used. If AXES=y, every second column "
                 "after the 2nd one (i.e. the 3rd, 5th, 7th etc) is assumed to "
                 "be an error bar for the value in the previous column.")
    parser.add_option("-o", "--output", metavar="FILE", dest="output",
            default=None, help="save the output to the given FILE")
    parser.add_option("--title", metavar="TITLE", dest="title",
            default=None, help="set the title of the plot to TITLE. "
            "The default title is the input filename.")
    parser.add_option("--xlabel", metavar="LABEL", dest="xlabel",
            default="", help="set the label of the X axis to LABEL")
    parser.add_option("--ylabel", metavar="LABEL", dest="ylabel",
            default="", help="set the title of the Y axis to LABEL")

    return parser

def plot_file(infile, options):
    """Plots the dataset in the given file."""
    plt.figure()

    xs = []
    yss = []
    headers = None
    for line in open_anything(infile):
        parts = line.strip("\r\n").split(options.delimiter)

        if not options.fields:
            values = [lenient_float(num, default=NaN) for num in parts]
        else:
            values = [lenient_float(parts[i-1], default=NaN)
                    for i in options.fields]

        if not yss:
            # No data yet, maybe this is the header?
            if any(value is None for value in values):
                headers = list(parts)
                continue

        # Less than two values? If so, skip this line.
        if len(values) < 2:
            continue

        # The first value is the X coordinate. We put the
        # rest in yss and will separate them later into Y
        # coordinates and error bars if options.errorbars
        # is not none
        xs.append(values[0])
        if not yss:
            # First row, must extend yss with columns
            yss = [[y] for y in islice(values, 1, None)]
        else:
            for ys, y in izip(yss, islice(values, 1, None)):
                ys.append(y)

    # Calculate the legend labels
    legend = []
    if yss and headers is not None:
        if options.fields:
            idxs = [f-1 for f in options.fields[1:]]
        else:
            idxs = range(1, len(yss)+1)
        legend = [headers[idx] for idx in idxs]

    # Mask NaNs in xs
    xs = array(xs)
    xs = masked_where(isnan(xs), xs)

    # Mask NaNs in yss
    yss = array(yss)
    yss = masked_where(isnan(yss), yss)

    # Handle error bars
    if options.errorbars == "y":
        # Separate the error bars from the values
        ncol = len(yss)
        errorbars = yss[1::2]
        yss = yss[::2]
        legend = legend[:min(len(legend), ncol):2]
    else:
        # No error bars
        errorbars = None

    # Set up the line styles to be used
    colors = 'bgrcmyk'
    styles = '- -- -. :'.split()
    line_styles = [color+style for style in styles for color in colors]
    bar_styles = [color+'o' for style in styles for color in colors]

    # Plot the lines
    args = []
    for style, ys in izip(cycle(line_styles), yss):
        args.extend([xs, ys, style])
    plt.plot(*args)

    # Plot the error bars if needed
    if errorbars is not None:
        for style, ys, yerrs in izip(cycle(bar_styles), yss, errorbars):
            plt.errorbar(xs, ys, yerr=yerrs, fmt=style)

    # Add the title
    if options.title is None:
        plt.title(infile)
    else:
        plt.title(options.title)

    # Add the axis titles
    if options.xlabel:
        plt.xlabel(options.xlabel)
    if options.ylabel:
        plt.ylabel(options.ylabel)

    # Add the legend
    if legend:
        legend_obj = plt.legend(legend)
        legend_obj.legendPatch.set_alpha(0.75)

def main():
    """Main entry point of the script."""
    parser = create_option_parser()
    options, args = parser.parse_args()

    if options.fields:
        options.fields = list(options.fields)

    if not args:
        args.extend("-")

    for infile in args:
        plot_file(infile, options)

    if options.output:
        plt.savefig(options.output)
    else:
        plt.show()

if __name__ == "__main__":
    try:
        sys.exit(main())
    except Exception as ex:
        print >>sys.stderr, ex
        import traceback
        traceback.print_exc(ex)
        sys.exit(1)
